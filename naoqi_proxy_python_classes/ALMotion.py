#!/usr/bin/env python
# Class autogenerated from ./almotionproxy.h
# by Sammy Pfeiffer's <Sammy.Pfeiffer at student.uts.edu.au> generator
# You need an ALBroker running

from naoqi import ALProxy


class ALMotion(object):
    def __init__(self):
        self.proxy = ALProxy("ALMotion")

    def getGenericProxy(self):
        """Gets the underlying generic proxy

        :returns boost::shared_ptr<ALProxy>: 
        """
        return self.proxy.getGenericProxy()

    def angleInterpolation(self, names, angleLists, timeLists, isAbsolute):
        """Interpolates one or multiple joints to a target angle or along timed trajectories. This is a blocking call.

        :param AL::ALValue names: Name or names of joints, chains, "Body", "JointActuators", "Joints" or "Actuators".
        :param AL::ALValue angleLists: An angle, list of angles or list of list of angles in radians
        :param AL::ALValue timeLists: A time, list of times or list of list of times in seconds
        :param bool isAbsolute: If true, the movement is described in absolute angles, else the angles are relative to the current angle.
        """
        return self.proxy.angleInterpolation(names, angleLists, timeLists, isAbsolute)

    def angleInterpolationBezier(self, jointNames, times, controlPoints):
        """Interpolates a sequence of timed angles for several motors using bezier control points. This is a blocking call.

        :param std::vector<std::string> jointNames: A vector of joint names
        :param AL::ALValue times: An ragged ALValue matrix of floats. Each line corresponding to a motor, and column element to a control point.
        :param AL::ALValue controlPoints: An ALValue array of arrays each containing [float angle, Handle1, Handle2], where Handle is [int InterpolationType, float dAngle, float dTime] descibing the handle offsets relative to the angle and time of the point. The first bezier param describes the handle that controls the curve preceeding the point, the second describes the curve following the point.
        """
        return self.proxy.angleInterpolationBezier(jointNames, times, controlPoints)

    def angleInterpolationWithSpeed(self, names, targetAngles, maxSpeedFraction):
        """Interpolates one or multiple joints to a target angle, using a fraction of max speed. Only one target angle is allowed for each joint. This is a blocking call.

        :param AL::ALValue names: Name or names of joints, chains, "Body", "JointActuators", "Joints" or "Actuators".
        :param AL::ALValue targetAngles: An angle, or list of angles in radians
        :param float maxSpeedFraction: A fraction.
        """
        return self.proxy.angleInterpolationWithSpeed(names, targetAngles, maxSpeedFraction)

    def areNotificationsEnabled(self):
        """Return true if notifications are active.

        :returns bool: Return True if notifications are active.
        """
        return self.proxy.areNotificationsEnabled()

    def areResourcesAvailable(self, resourceNames):
        """Returns true if all the desired resources are available. Only motion API's' blocking call takes resources.

        :param std::vector<std::string> resourceNames: A vector of resource names such as joints. Use getBodyNames("Body") to have the list of the available joint for your robot.
        :returns bool: True if the resources are available
        """
        return self.proxy.areResourcesAvailable(resourceNames)

    def changeAngles(self, names, changes, fractionMaxSpeed):
        """Changes Angles. This is a non-blocking call.

        :param AL::ALValue names: The name or names of joints, chains, "Body", "JointActuators", "Joints" or "Actuators".
        :param AL::ALValue changes: One or more changes in radians
        :param float fractionMaxSpeed: The fraction of maximum speed to use
        """
        return self.proxy.changeAngles(names, changes, fractionMaxSpeed)

    def changePosition(self, effectorName, space, positionChange, fractionMaxSpeed, axisMask):
        """DEPRECATED. Use setPositions function instead.

        :param str effectorName: Name of the effector.
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param std::vector<float> positionChange: 6D position change array (xd, yd, zd, wxd, wyd, wzd) in meters and radians
        :param float fractionMaxSpeed: The fraction of maximum speed to use
        :param int axisMask: Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        """
        return self.proxy.changePosition(effectorName, space, positionChange, fractionMaxSpeed, axisMask)

    def changeTransform(self, chainName, space, transform, fractionMaxSpeed, axisMask):
        """DEPRECATED. Use setTransforms function instead.

        :param str chainName: Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg", "Torso"
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param std::vector<float> transform: Transform arrays
        :param float fractionMaxSpeed: The fraction of maximum speed to use
        :param int axisMask: Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        """
        return self.proxy.changeTransform(chainName, space, transform, fractionMaxSpeed, axisMask)

    def closeHand(self, handName):
        """NAO stiffens the motors of desired hand. Then, he closes the hand, then cuts motor current to conserve energy. This is a blocking call.

        :param str handName: The name of the hand. Could be: "RHand" or "LHand"
        """
        return self.proxy.closeHand(handName)

    def exit(self):
        """Exits and unregisters the module.
        """
        return self.proxy.exit()

    def getAngles(self, names, useSensors):
        """Gets the angles of the joints

        :param AL::ALValue names: Names the joints, chains, "Body", "JointActuators", "Joints" or "Actuators".
        :param bool useSensors: If true, sensor angles will be returned
        :returns std::vector<float>: Joint angles in radians.
        """
        return self.proxy.getAngles(names, useSensors)

    def getBodyNames(self, name):
        """Gets the names of all the joints and actuators in the collection.

        :param str name: Name of a chain, "Arms", "Legs", "Body", "Chains", "JointActuators", "Joints" or "Actuators".
        :returns std::vector<std::string>: Vector of strings, one for each joint and actuator in the collection
        """
        return self.proxy.getBodyNames(name)

    def getBreathConfig(self):
        """This function gets the current breathing configuration. bpm is the breathing frequency in beats per minute. amplitude is the normalized amplitude of the breathing animation, between 0 and 1.

        :returns AL::ALValue: An ALValue of the form [["Bpm", bpm], ["Amplitude", amplitude]].
        """
        return self.proxy.getBreathConfig()

    def getBreathEnabled(self, pChain):
        """This function gets the status of breathing animation on a chain. Chain name can be "Body", "Arms", "LArm", "RArm", "Legs" or "Head".

        :param str pChain: Chain name.
        :returns bool: True if breathing animation is enabled on the chain.
        """
        return self.proxy.getBreathEnabled(pChain)

    def getBrokerName(self):
        """Gets the name of the parent broker.

        :returns str: The name of the parent broker.
        """
        return self.proxy.getBrokerName()

    def getCOM(self, pName, pSpace, pUseSensorValues):
        """Gets the COM of a joint, chain, "Body" or "Joints".

        :param str pName: Name of the body which we want the mass. In chain name case, this function give the com of the chain.
        :param int pSpace: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param bool pUseSensorValues: If true, the sensor values will be used to determine the position.
        :returns std::vector<float>: The COM position (meter).
        """
        return self.proxy.getCOM(pName, pSpace, pUseSensorValues)

    def getChainClosestObstaclePosition(self, pName, space):
        """Gets chain closest obstacle Position .

        :param str pName: The Chain name {"LArm" or "RArm"}.
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :returns std::vector<float>: Vector containing the Position3D in meters (x, y, z)
        """
        return self.proxy.getChainClosestObstaclePosition(pName, space)

    def getCollisionProtectionEnabled(self, pChainName):
        """Allow to know if the collision protection is activated on the given chain.

        :param str pChainName: The chain name {"LArm" or "RArm"}.
        :returns bool: Return true is the collision protection of the given Arm is activated.
        """
        return self.proxy.getCollisionProtectionEnabled(pChainName)

    def getDiagnosisEffectEnabled(self):
        """Give the state of the diagnosis effect.

        :returns bool: Return true is the diagnosis reflex is activated.
        """
        return self.proxy.getDiagnosisEffectEnabled()

    def getExternalCollisionProtectionEnabled(self, pName):
        """Allow to know if the external collision protection is activated on the given name.

        :param str pName: The name {"All", "Move", "Arms", "LArm" or "RArm"}.
        :returns bool: Return true is the external collision protection of the given name is activated.
        """
        return self.proxy.getExternalCollisionProtectionEnabled(pName)

    def getFallManagerEnabled(self):
        """Give the state of the fall manager.

        :returns bool: Return true is the fall manager is activated.
        """
        return self.proxy.getFallManagerEnabled()

    def getFootGaitConfig(self, config):
        """DEPRECATED. Use getMoveConfig function instead. Gets the foot Gait config ("MaxStepX", "MaxStepY", "MaxStepTheta",  "MaxStepFrequency", "StepHeight", "TorsoWx", "TorsoWy")

        :param str config: a string should be "Max", "Min", "Default"  ["MaxStepY", value],  ["MaxStepTheta", value],  ["MaxStepFrequency", value],  ["StepHeight", value],  ["TorsoWx", value],  ["TorsoWy", value]]
        :returns AL::ALValue: An ALvalue with the following form :[["MaxStepX", value],
        """
        return self.proxy.getFootGaitConfig(config)

    def getFootSteps(self):
        """Get the foot steps. This is a non-blocking call.

        :returns AL::ALValue: Give two list of foot steps. The first one give the unchangeable foot step. The second list give the changeable foot steps. Il you use setFootSteps or setFootStepsWithSpeed with clearExisting parmater equal true, walk engine execute unchangeable foot step and remove the other.
        """
        return self.proxy.getFootSteps()

    def getIdlePostureEnabled(self, pChain):
        """This function gets the status of idle posture management on a chain. Chain name can be "Body", "Arms", "LArm", "RArm", "Legs" or "Head".

        :param str pChain: Chain name.
        :returns bool: True if breathing animation is enabled on the chain.
        """
        return self.proxy.getIdlePostureEnabled(pChain)

    def getJointNames(self, name):
        """DEPRECATED. Use getBodyNames function instead.

        :param str name: Name of a chain, "Arms", "Legs", "Body", "Chains", "JointActuators", "Joints" or "Actuators".
        :returns std::vector<std::string>: Vector of strings, one for each joint in the collection
        """
        return self.proxy.getJointNames(name)

    def getLimits(self, name):
        """Get the minAngle (rad), maxAngle (rad), and maxVelocity (rad.s-1) for a given joint or actuator in the body.

        :param str name: Name of a joint, chain, "Body", "JointActuators", "Joints" or "Actuators".
        :returns AL::ALValue: Array of ALValue arrays containing the minAngle, maxAngle, maxVelocity and maxTorque for all the bodies specified.
        """
        return self.proxy.getLimits(name)

    def getMass(self, pName):
        """Gets the mass of a joint, chain, "Body" or "Joints".

        :param str pName: Name of the body which we want the mass. "Body", "Joints" and "Com" give the total mass of nao. For the chain, it gives the total mass of the chain.
        :returns float: The mass in kg.
        """
        return self.proxy.getMass(pName)

    def getMethodHelp(self, methodName):
        """Retrieves a method's description.

        :param str methodName: The name of the method.
        :returns AL::ALValue: A structure containing the method's description.
        """
        return self.proxy.getMethodHelp(methodName)

    def getMethodList(self):
        """Retrieves the module's method list.

        :returns std::vector<std::string>: An array of method names.
        """
        return self.proxy.getMethodList()

    def getModuleHelp(self):
        """Retrieves the module's description.

        :returns AL::ALValue: A structure describing the module.
        """
        return self.proxy.getModuleHelp()

    def getMotionCycleTime(self):
        """Get the motion cycle time in milliseconds.

        :returns int: Expressed in milliseconds
        """
        return self.proxy.getMotionCycleTime()

    def getMoveArmsEnabled(self, chainName):
        """Gets if Arms Motions are enabled during the Move Process.

        :param str chainName: Name of the chain. Could be: "LArm", "RArm" or "Arms"
        :returns bool: For LArm and RArm true if the corresponding arm is enabled. For Arms, true if both are enabled. False otherwise.
        """
        return self.proxy.getMoveArmsEnabled(chainName)

    def getMoveConfig(self, config):
        """Gets the move config.

        :param str config: a string should be "Max", "Min", "Default"
        :returns AL::ALValue: An ALvalue with the move config
        """
        return self.proxy.getMoveConfig(config)

    def getNextRobotPosition(self):
        """Gets the World Absolute next Robot Position. In fact in the walk algorithm some foot futur foot step are incompressible due to preview control, so this function give the next robot position which is incompressible. If the robot doesn't walk this function is equivalent to getRobotPosition(false)

        :returns std::vector<float>: A vector containing the World Absolute next Robot position.(Absolute Position X, Absolute Position Y, Absolute Angle Z)
        """
        return self.proxy.getNextRobotPosition()

    def getOrthogonalSecurityDistance(self):
        """Gets the current orthogonal security distance.

        :returns float: The current orthogonal security distance.
        """
        return self.proxy.getOrthogonalSecurityDistance()

    def getPosition(self, name, space, useSensorValues):
        """Gets a Position relative to the FRAME. Axis definition: the x axis is positive toward Nao's front, the y from right to left and the z is vertical. The angle convention of Position6D is Rot_z(wz).Rot_y(wy).Rot_x(wx).

        :param str name: Name of the item. Could be: Head, LArm, RArm, LLeg, RLeg, Torso, CameraTop, CameraBottom, MicroFront, MicroRear, MicroLeft, MicroRight, Accelerometer, Gyrometer, Laser, LFsrFR, LFsrFL, LFsrRR, LFsrRL, RFsrFR, RFsrFL, RFsrRR, RFsrRL, USSensor1, USSensor2, USSensor3, USSensor4. Use getSensorNames for the list of sensors supported on your robot.
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param bool useSensorValues: If true, the sensor values will be used to determine the position.
        :returns std::vector<float>: Vector containing the Position6D using meters and radians (x, y, z, wx, wy, wz)
        """
        return self.proxy.getPosition(name, space, useSensorValues)

    def getPushRecoveryEnabled(self):
        """Give the state of the push recovery.

        :returns bool: Return true is the push recovery is activated.
        """
        return self.proxy.getPushRecoveryEnabled()

    def getRobotConfig(self):
        """Get the robot configuration.

        :returns AL::ALValue: ALValue arrays containing the robot parameter names and the robot parameter values.
        """
        return self.proxy.getRobotConfig()

    def getRobotPosition(self, useSensors):
        """Gets the World Absolute Robot Position.

        :param bool useSensors: If true, use the sensor values
        :returns std::vector<float>: A vector containing the World Absolute Robot Position. (Absolute Position X, Absolute Position Y, Absolute Angle Z)
        """
        return self.proxy.getRobotPosition(useSensors)

    def getRobotVelocity(self):
        """Gets the World Absolute Robot Velocity.

        :returns std::vector<float>: A vector containing the World Absolute Robot Velocity. (Absolute Velocity Translation X [m.s-1], Absolute Velocity Translation Y[m.s-1], Absolute Velocity Rotation WZ [rd.s-1])
        """
        return self.proxy.getRobotVelocity()

    def getSensorNames(self):
        """Gets the list of sensors supported on your robot.

        :returns std::vector<std::string>: Vector of sensor names
        """
        return self.proxy.getSensorNames()

    def getSmartStiffnessEnabled(self):
        """Give the state of the smart Stiffness.

        :returns bool: Return true is the smart Stiffnes is activated.
        """
        return self.proxy.getSmartStiffnessEnabled()

    def getStiffnesses(self, jointName):
        """Gets stiffness of a joint or group of joints

        :param AL::ALValue jointName: Name of the joints, chains, "Body", "Joints" or "Actuators".
        :returns std::vector<float>: One or more stiffnesses. 1.0 indicates maximum stiffness. 0.0 indicated minimum stiffness
        """
        return self.proxy.getStiffnesses(jointName)

    def getSummary(self):
        """Returns a string representation of the Model's state

        :returns str: A formated string
        """
        return self.proxy.getSummary()

    def getTangentialSecurityDistance(self):
        """Gets the current tangential security distance.

        :returns float: The current tangential security distance.
        """
        return self.proxy.getTangentialSecurityDistance()

    def getTaskList(self):
        """Gets an ALValue structure describing the tasks in the Task List

        :returns AL::ALValue: An ALValue containing an ALValue for each task. The inner ALValue contains: Name, MotionID
        """
        return self.proxy.getTaskList()

    def getTransform(self, name, space, useSensorValues):
        """Gets an Homogenous Transform relative to the FRAME. Axis definition: the x axis is positive toward Nao's front, the y from right to left and the z is vertical.

        :param str name: Name of the item. Could be: any joint or chain or sensor (Head, LArm, RArm, LLeg, RLeg, Torso, HeadYaw, ..., CameraTop, CameraBottom, MicroFront, MicroRear, MicroLeft, MicroRight, Accelerometer, Gyrometer, Laser, LFsrFR, LFsrFL, LFsrRR, LFsrRL, RFsrFR, RFsrFL, RFsrRR, RFsrRL, USSensor1, USSensor2, USSensor3, USSensor4. Use getSensorNames for the list of sensors supported on your robot.
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param bool useSensorValues: If true, the sensor values will be used to determine the position.
        :returns std::vector<float>: Vector of 16 floats corresponding to the values of the matrix, line by line.
        """
        return self.proxy.getTransform(name, space, useSensorValues)

    def getUsage(self, name):
        """Gets the method usage string. This summarises how to use the method.

        :param str name: The name of the method.
        :returns str: A string that summarises the usage of the method.
        """
        return self.proxy.getUsage(name)

    def getWalkArmsEnabled(self):
        """DEPRECATED. Gets if Arms Motions are enabled during the Walk Process.

        :returns AL::ALValue: True Arm Motions are controlled by the Walk Task.
        """
        return self.proxy.getWalkArmsEnabled()

    def isCollision(self, pChainName):
        """Give the collision state of a chain. If a chain has a collision state "none" or "near", it could be desactivated.

        :param str pChainName: The chain name {"Arms", "LArm" or "RArm"}.
        :returns str: A string which notice the collision state: "none" there are no collision, "near" the collision is taking in account in the anti-collision algorithm, "collision" the chain is in contact with an other body. If the chain asked is "Arms" the most unfavorable result is given.
        """
        return self.proxy.isCollision(pChainName)

    def isRunning(self, id):
        """Returns true if the method is currently running.

        :param int id: The ID of the method that was returned when calling the method using 'post'
        :returns bool: True if the method is currently running
        """
        return self.proxy.isRunning(id)

    def killAll(self):
        """Kills all tasks.
        """
        return self.proxy.killAll()

    def killMove(self):
        """Emergency Stop on Move task: This method will end the move task brutally, without attempting to return to a balanced state. The robot could easily fall.
        """
        return self.proxy.killMove()

    def killTask(self, motionTaskID):
        """Kills a motion task.

        :param int motionTaskID: TaskID of the motion task you want to kill.
        :returns bool: Return true if the specified motionTaskId has been killed.
        """
        return self.proxy.killTask(motionTaskID)

    def killTasksUsingResources(self, resourceNames):
        """Kills all tasks that use any of the resources given. Only motion API's' blocking call takes resources and can be killed. Use getBodyNames("Body") to have the list of the available joint for your robot.

        :param std::vector<std::string> resourceNames: A vector of resource joint names
        """
        return self.proxy.killTasksUsingResources(resourceNames)

    def killWalk(self):
        """DEPRECATED. Use killMove function instead.
        """
        return self.proxy.killWalk()

    def move(self, x, y, theta):
        """Makes the robot move at the given velocity. This is a non-blocking call.

        :param float x: The velocity along x axis [m.s-1].
        :param float y: The velocity along y axis [m.s-1].
        :param float theta: The velocity around z axis [rd.s-1].
        """
        return self.proxy.move(x, y, theta)

    def move(self, x, y, theta, moveConfig):
        """Makes the robot move at the given velocity. This is a non-blocking call.

        :param float x: The velocity along x axis [m.s-1].
        :param float y: The velocity along y axis [m.s-1].
        :param float theta: The velocity around z axis [rd.s-1].
        :param AL::ALValue moveConfig: An ALValue with custom move configuration.
        """
        return self.proxy.move(x, y, theta, moveConfig)

    def moveInit(self):
        """Initialize the move process. Check the robot pose and take a right posture. This is blocking called.
        """
        return self.proxy.moveInit()

    def moveIsActive(self):
        """Check if the move process is actif.

        :returns bool: True if move is active
        """
        return self.proxy.moveIsActive()

    def moveTo(self, x, y, theta):
        """Makes the robot move at the given position. This is a non-blocking call.

        :param float x: The position along x axis [m].
        :param float y: The position along y axis [m].
        :param float theta: The position around z axis [rd].
        """
        return self.proxy.moveTo(x, y, theta)

    def moveTo(self, x, y, theta, time):
        """Makes the robot move at the given position in fixed time. This is a non-blocking call.

        :param float x: The position along x axis [m].
        :param float y: The position along y axis [m].
        :param float theta: The position around z axis [rd].
        :param float time: The time to reach the target position [s].
        """
        return self.proxy.moveTo(x, y, theta, time)

    def moveTo(self, x, y, theta, moveConfig):
        """Makes the robot move at the given position. This is a non-blocking call.

        :param float x: The position along x axis [m].
        :param float y: The position along y axis [m].
        :param float theta: The position around z axis [rd].
        :param AL::ALValue moveConfig: An ALValue with custom move configuration.
        """
        return self.proxy.moveTo(x, y, theta, moveConfig)

    def moveTo(self, x, y, theta, time, moveConfig):
        """Makes the robot move at the given position in fixed time. This is a non-blocking call.

        :param float x: The position along x axis [m].
        :param float y: The position along y axis [m].
        :param float theta: The position around z axis [rd].
        :param float time: The time to reach the target position [s].
        :param AL::ALValue moveConfig: An ALValue with custom move configuration.
        """
        return self.proxy.moveTo(x, y, theta, time, moveConfig)

    def moveTo(self, controlPoint):
        """Makes the robot move to the given relative positions. This is a blocking call.

        :param AL::ALValue controlPoint: An ALValue with the control points in FRAME_ROBOT. Each control point is relative to the previous one. [[x1, y1, theta1], ..., [xN, yN, thetaN]
        """
        return self.proxy.moveTo(controlPoint)

    def moveTo(self, controlPoint, moveConfig):
        """Makes the robot move to the given relative positions. This is a blocking call.

        :param AL::ALValue controlPoint: An ALValue with all the control points in FRAME_ROBOT. Each control point is relative to the previous one. [[x1, y1, theta1], ..., [xN, yN, thetaN]
        :param AL::ALValue moveConfig: An ALValue with custom move configuration.
        """
        return self.proxy.moveTo(controlPoint, moveConfig)

    def moveToward(self, x, y, theta):
        """Makes the robot move at the given normalized velocity. This is a non-blocking call.

        :param float x: The normalized velocity along x axis (between -1 and 1).
        :param float y: The normalized velocity along y axis (between -1 and 1).
        :param float theta: The normalized velocity around z axis (between -1 and 1).
        """
        return self.proxy.moveToward(x, y, theta)

    def moveToward(self, x, y, theta, moveConfig):
        """Makes the robot move at the given normalized velocity. This is a non-blocking call.

        :param float x: The normalized velocity along x axis (between -1 and 1).
        :param float y: The normalized velocity along y axis (between -1 and 1).
        :param float theta: The normalized velocity around z axis (between -1 and 1).
        :param AL::ALValue moveConfig: An ALValue with custom move configuration.
        """
        return self.proxy.moveToward(x, y, theta, moveConfig)

    def openHand(self, handName):
        """NAO stiffens the motors of desired hand. Then, he opens the hand, then cuts motor current to conserve energy. This is a blocking call.

        :param str handName: The name of the hand. Could be: "RHand or "LHand"
        """
        return self.proxy.openHand(handName)

    def pCall(self):
        """NAOqi1 pCall method.

        :returns AL::ALValue: 
        """
        return self.proxy.pCall()

    def ping(self):
        """Just a ping. Always returns true

        :returns bool: returns true
        """
        return self.proxy.ping()

    def positionInterpolation(self, chainName, space, path, axisMask, durations, isAbsolute):
        """DEPRECATED. Use positionInterpolations function instead.

        :param str chainName: Name of the chain. Could be: "Head", "LArm", "RArm", "LLeg", "RLeg", "Torso"
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param AL::ALValue path: Vector of 6D position arrays (x,y,z,wx,wy,wz) in meters and radians
        :param int axisMask: Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        :param AL::ALValue durations: Vector of times in seconds corresponding to the path points
        :param bool isAbsolute: If true, the movement is absolute else relative
        """
        return self.proxy.positionInterpolation(chainName, space, path, axisMask, durations, isAbsolute)

    def positionInterpolations(self, effectorNames, taskSpaceForAllPaths, paths, axisMasks, relativeTimes, isAbsolute):
        """DEPRECATED. Use the other positionInterpolations function instead.

        :param std::vector<std::string> effectorNames: Vector of chain names. Could be: "Head", "LArm", "RArm", "LLeg", "RLeg", "Torso"
        :param int taskSpaceForAllPaths: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param AL::ALValue paths: Vector of 6D position arrays (x,y,z,wx,wy,wz) in meters and radians
        :param AL::ALValue axisMasks: Vector of Axis Masks. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        :param AL::ALValue relativeTimes: Vector of times in seconds corresponding to the path points
        :param bool isAbsolute: If true, the movement is absolute else relative
        """
        return self.proxy.positionInterpolations(effectorNames, taskSpaceForAllPaths, paths, axisMasks, relativeTimes, isAbsolute)

    def positionInterpolations(self, effectorNames, taskSpaceForAllPaths, paths, axisMasks, relativeTimes):
        """Moves end-effectors to the given positions and orientations over time. This is a blocking call.

        :param AL::ALValue effectorNames: Vector of chain names. Could be: "Head", "LArm", "RArm", "LLeg", "RLeg", "Torso"
        :param AL::ALValue taskSpaceForAllPaths: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param AL::ALValue paths: Vector of 6D position arrays (x,y,z,wx,wy,wz) in meters and radians
        :param AL::ALValue axisMasks: Vector of Axis Masks. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        :param AL::ALValue relativeTimes: Vector of times in seconds corresponding to the path points
        """
        return self.proxy.positionInterpolations(effectorNames, taskSpaceForAllPaths, paths, axisMasks, relativeTimes)

    def rest(self):
        """The robot will rest: go to a relax and safe position and set Motor OFF
        """
        return self.proxy.rest()

    def rest(self, arg1):
        """The robot will rest: go to a relax and safe position on the chain and set Motor OFF

        :param str arg1: arg
        """
        return self.proxy.rest(arg1)

    def robotIsWakeUp(self):
        """return true if the robot is already wakeUp

        :returns bool: True if the robot is already wakeUp.
        """
        return self.proxy.robotIsWakeUp()

    def setAngles(self, names, angles, fractionMaxSpeed):
        """Sets angles. This is a non-blocking call.

        :param AL::ALValue names: The name or names of joints, chains, "Body", "JointActuators", "Joints" or "Actuators".
        :param AL::ALValue angles: One or more angles in radians
        :param float fractionMaxSpeed: The fraction of maximum speed to use
        """
        return self.proxy.setAngles(names, angles, fractionMaxSpeed)

    def setBreathConfig(self, pConfig):
        """This function configures the breathing animation.

        :param AL::ALValue pConfig: Breath configuration. An ALValue of the form [["Bpm", pBpm], ["Amplitude", pAmplitude]]. pBpm is a float between 10 and 50 setting the breathing frequency in beats per minute. pAmplitude is a float between 0 and 1 setting the amplitude of the breathing animation.
        """
        return self.proxy.setBreathConfig(pConfig)

    def setBreathEnabled(self, pChain, pIsEnabled):
        """This function starts or stops breathing animation on a chain. Chain name can be "Body", "Arms", "LArm", "RArm", "Legs" or "Head". Head breathing animation will work only if Leg animation is active.

        :param str pChain: Chain name.
        :param bool pIsEnabled: Enables / disables the chain.
        """
        return self.proxy.setBreathEnabled(pChain, pIsEnabled)

    def setCollisionProtectionEnabled(self, pChainName, pEnable):
        """Enable Anticollision protection of the arms of the robot. Use api isCollision to know if a chain is in collision and can be disactivated.

        :param str pChainName: The chain name {"Arms", "LArm" or "RArm"}.
        :param bool pEnable: Activate or disactivate the anticollision of the desired Chain.
        :returns bool: A bool which return always true.
        """
        return self.proxy.setCollisionProtectionEnabled(pChainName, pEnable)

    def setDiagnosisEffectEnabled(self, pEnable):
        """Enable or disable the diagnosis effect into ALMotion

        :param bool pEnable: Enable or disable the diagnosis effect.
        """
        return self.proxy.setDiagnosisEffectEnabled(pEnable)

    def setEnableNotifications(self, enable):
        """Enable / Disable notifications.

        :param bool enable: If True enable notifications. If False disable notifications.
        """
        return self.proxy.setEnableNotifications(enable)

    def setExternalCollisionProtectionEnabled(self, pName, pEnable):
        """Enable Anticollision protection of the arms and base move  of the robot with external environment.

        :param str pName: The name {"All", "Move", "Arms", "LArm" or "RArm"}.
        :param bool pEnable: Activate or disactivate the anticollision of the desired name.
        """
        return self.proxy.setExternalCollisionProtectionEnabled(pName, pEnable)

    def setFallManagerEnabled(self, pEnable):
        """Enable The fall manager protection for the robot. When a fall is detected the robot adopt a joint configuration to protect himself and cut the stiffness. . An memory event called "robotHasFallen" is generated when the fallManager have been activated.

        :param bool pEnable: Activate or disactivate the smart stiffness.
        """
        return self.proxy.setFallManagerEnabled(pEnable)

    def setFootSteps(self, legName, footSteps, timeList, clearExisting):
        """Makes Nao do foot step planner. This is a non-blocking call.

        :param std::vector<std::string> legName: name of the leg to move('LLeg'or 'RLeg')
        :param AL::ALValue footSteps: [x, y, theta], [Position along X/Y, Orientation round Z axis] of the leg relative to the other Leg in [meters, meters, radians]. Must be less than [MaxStepX, MaxStepY, MaxStepTheta]
        :param std::vector<float> timeList: time list of each foot step
        :param bool clearExisting: Clear existing foot steps.
        """
        return self.proxy.setFootSteps(legName, footSteps, timeList, clearExisting)

    def setFootStepsWithSpeed(self, legName, footSteps, fractionMaxSpeed, clearExisting):
        """Makes Nao do foot step planner with speed. This is a blocking call.

        :param std::vector<std::string> legName: name of the leg to move('LLeg'or 'RLeg')
        :param AL::ALValue footSteps: [x, y, theta], [Position along X/Y, Orientation round Z axis] of the leg relative to the other Leg in [meters, meters, radians]. Must be less than [MaxStepX, MaxStepY, MaxStepTheta]
        :param std::vector<float> fractionMaxSpeed: speed of each foot step. Must be between 0 and 1.
        :param bool clearExisting: Clear existing foot steps.
        """
        return self.proxy.setFootStepsWithSpeed(legName, footSteps, fractionMaxSpeed, clearExisting)

    def setIdlePostureEnabled(self, pChain, pIsEnabled):
        """Starts or stops idle posture management on a chain. Chain name can be "Body", "Arms", "LArm", "RArm", "Legs" or "Head".

        :param str pChain: Chain name.
        :param bool pIsEnabled: Enables / disables the chain.
        """
        return self.proxy.setIdlePostureEnabled(pChain, pIsEnabled)

    def setMotionConfig(self, config):
        """Internal Use.

        :param AL::ALValue config: Internal: An array of ALValues [i][0]: name, [i][1]: value
        """
        return self.proxy.setMotionConfig(config)

    def setMoveArmsEnabled(self, leftArmEnabled, rightArmEnabled):
        """Sets if Arms Motions are enabled during the Move Process.

        :param bool leftArmEnabled: if true Left Arm motions are controlled by the Move Task
        :param bool rightArmEnabled: if true Right Arm mMotions are controlled by the Move Task
        """
        return self.proxy.setMoveArmsEnabled(leftArmEnabled, rightArmEnabled)

    def setOrthogonalSecurityDistance(self, securityDistance):
        """Defines the orthogonal security distance used with external collision protection "Move".

        :param float securityDistance: The orthogonal security distance.
        """
        return self.proxy.setOrthogonalSecurityDistance(securityDistance)

    def setPosition(self, chainName, space, position, fractionMaxSpeed, axisMask):
        """Moves an end-effector to DEPRECATED. Use setPositions function instead.

        :param str chainName: Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg", "Torso"
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param std::vector<float> position: 6D position array (x,y,z,wx,wy,wz) in meters and radians
        :param float fractionMaxSpeed: The fraction of maximum speed to use
        :param int axisMask: Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        """
        return self.proxy.setPosition(chainName, space, position, fractionMaxSpeed, axisMask)

    def setPositions(self, names, spaces, positions, fractionMaxSpeed, axisMask):
        """Moves multiple end-effectors to the given position and orientation position6d. This is a non-blocking call.

        :param AL::ALValue names: The name or names of effector.
        :param AL::ALValue spaces: The task frame or task frames {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param AL::ALValue positions: Position6D arrays
        :param float fractionMaxSpeed: The fraction of maximum speed to use
        :param AL::ALValue axisMask: Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        """
        return self.proxy.setPositions(names, spaces, positions, fractionMaxSpeed, axisMask)

    def setPushRecoveryEnabled(self, pEnable):
        """Enable The push recovery protection for the robot.

        :param bool pEnable: Enable the push recovery.
        """
        return self.proxy.setPushRecoveryEnabled(pEnable)

    def setSmartStiffnessEnabled(self, pEnable):
        """Enable Smart Stiffness for all the joints (True by default), the update take one motion cycle for updating. The smart Stiffness is a gestion of joint maximum torque. More description is available on the red documentation of ALMotion module.

        :param bool pEnable: Activate or disactivate the smart stiffness.
        """
        return self.proxy.setSmartStiffnessEnabled(pEnable)

    def setStiffnesses(self, names, stiffnesses):
        """Sets the stiffness of one or more joints. This is a non-blocking call.

        :param AL::ALValue names: Names of joints, chains, "Body", "JointActuators", "Joints" or "Actuators".
        :param AL::ALValue stiffnesses: One or more stiffnesses between zero and one.
        """
        return self.proxy.setStiffnesses(names, stiffnesses)

    def setTangentialSecurityDistance(self, securityDistance):
        """Defines the tangential security distance used with external collision protection "Move".

        :param float securityDistance: The tangential security distance.
        """
        return self.proxy.setTangentialSecurityDistance(securityDistance)

    def setTransform(self, chainName, space, transform, fractionMaxSpeed, axisMask):
        """Moves an end-effector to DEPRECATED. Use setTransforms function instead.

        :param str chainName: Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg", "Torso"
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param std::vector<float> transform: Transform arrays
        :param float fractionMaxSpeed: The fraction of maximum speed to use
        :param int axisMask: Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        """
        return self.proxy.setTransform(chainName, space, transform, fractionMaxSpeed, axisMask)

    def setTransforms(self, names, spaces, transforms, fractionMaxSpeed, axisMask):
        """Moves multiple end-effectors to the given position and orientation transforms. This is a non-blocking call.

        :param AL::ALValue names: The name or names of effector.
        :param AL::ALValue spaces: The task frame or task frames {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param AL::ALValue transforms: Transform arrays
        :param float fractionMaxSpeed: The fraction of maximum speed to use
        :param AL::ALValue axisMask: Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        """
        return self.proxy.setTransforms(names, spaces, transforms, fractionMaxSpeed, axisMask)

    def setWalkArmsEnabled(self, leftArmEnabled, rightArmEnabled):
        """DEPRECATED. Sets if Arms Motions are enabled during the Walk Process.

        :param bool leftArmEnabled: if true Left Arm motions are controlled by the Walk Task
        :param bool rightArmEnabled: if true Right Arm mMotions are controlled by the Walk Task
        """
        return self.proxy.setWalkArmsEnabled(leftArmEnabled, rightArmEnabled)

    def setWalkTargetVelocity(self, x, y, theta, frequency):
        """DEPRECATED. Use moveToward() function instead.

        :param float x: Fraction of MaxStepX. Use negative for backwards. [-1.0 to 1.0]
        :param float y: Fraction of MaxStepY. Use negative for right. [-1.0 to 1.0]
        :param float theta: Fraction of MaxStepTheta. Use negative for clockwise [-1.0 to 1.0]
        :param float frequency: Fraction of MaxStepFrequency [0.0 to 1.0]
        """
        return self.proxy.setWalkTargetVelocity(x, y, theta, frequency)

    def setWalkTargetVelocity(self, x, y, theta, frequency, feetGaitConfig):
        """DEPRECATED. Use moveToward() function instead.

        :param float x: Fraction of MaxStepX. Use negative for backwards. [-1.0 to 1.0]
        :param float y: Fraction of MaxStepY. Use negative for right. [-1.0 to 1.0]
        :param float theta: Fraction of MaxStepTheta. Use negative for clockwise [-1.0 to 1.0]
        :param float frequency: Fraction of MaxStepFrequency [0.0 to 1.0]
        :param AL::ALValue feetGaitConfig: An ALValue with the custom gait configuration for both feet
        """
        return self.proxy.setWalkTargetVelocity(x, y, theta, frequency, feetGaitConfig)

    def setWalkTargetVelocity(self, x, y, theta, frequency, leftFootMoveConfig, rightFootMoveConfig):
        """DEPRECATED. Use moveToward() function instead.

        :param float x: Fraction of MaxStepX. Use negative for backwards. [-1.0 to 1.0]
        :param float y: Fraction of MaxStepY. Use negative for right. [-1.0 to 1.0]
        :param float theta: Fraction of MaxStepTheta. Use negative for clockwise [-1.0 to 1.0]
        :param float frequency: Fraction of MaxStepFrequency [0.0 to 1.0]
        :param AL::ALValue leftFootMoveConfig: An ALValue with custom move configuration for the left foot
        :param AL::ALValue rightFootMoveConfig: An ALValue with custom move configuration for the right foot
        """
        return self.proxy.setWalkTargetVelocity(x, y, theta, frequency, leftFootMoveConfig, rightFootMoveConfig)

    def stiffnessInterpolation(self, names, stiffnessLists, timeLists):
        """Interpolates one or multiple joints to a target stiffness or along timed trajectories of stiffness. This is a blocking call.

        :param AL::ALValue names: Name or names of joints, chains, "Body", "JointActuators", "Joints" or "Actuators".
        :param AL::ALValue stiffnessLists: An stiffness, list of stiffnesses or list of list of stiffnesses
        :param AL::ALValue timeLists: A time, list of times or list of list of times.
        """
        return self.proxy.stiffnessInterpolation(names, stiffnessLists, timeLists)

    def stop(self, id):
        """returns true if the method is currently running

        :param int id: the ID of the method to wait for
        """
        return self.proxy.stop(id)

    def stopMove(self):
        """Stop Move task safely as fast as possible. The move task is ended less brutally than killMove but more quickly than move(0.0, 0.0, 0.0). This is a blocking call.
        """
        return self.proxy.stopMove()

    def stopWalk(self):
        """DEPRECATED. Use stopMove function instead.
        """
        return self.proxy.stopWalk()

    def transformInterpolation(self, chainName, space, path, axisMask, duration, isAbsolute):
        """DEPRECATED. Use the other transformInterpolations function instead.

        :param str chainName: Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg", "Torso"
        :param int space: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param AL::ALValue path: Vector of Transform arrays
        :param int axisMask: Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        :param AL::ALValue duration: Vector of times in seconds corresponding to the path points
        :param bool isAbsolute: If true, the movement is absolute else relative
        """
        return self.proxy.transformInterpolation(chainName, space, path, axisMask, duration, isAbsolute)

    def transformInterpolations(self, effectorNames, taskSpaceForAllPaths, paths, axisMasks, relativeTimes, isAbsolute):
        """DEPRECATED. Use the other transformInterpolations function instead.

        :param std::vector<std::string> effectorNames: Vector of chain names. Could be: "Head", "LArm", "RArm", "LLeg", "RLeg", "Torso"
        :param int taskSpaceForAllPaths: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param AL::ALValue paths: Vector of transforms arrays.
        :param AL::ALValue axisMasks: Vector of Axis Masks. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        :param AL::ALValue relativeTimes: Vector of times in seconds corresponding to the path points
        :param bool isAbsolute: If true, the movement is absolute else relative
        """
        return self.proxy.transformInterpolations(effectorNames, taskSpaceForAllPaths, paths, axisMasks, relativeTimes, isAbsolute)

    def transformInterpolations(self, effectorNames, taskSpaceForAllPaths, paths, axisMasks, relativeTimes):
        """Moves end-effectors to the given positions and orientations over time. This is a blocking call.

        :param AL::ALValue effectorNames: Vector of chain names. Could be: "Head", "LArm", "RArm", "LLeg", "RLeg", "Torso"
        :param AL::ALValue taskSpaceForAllPaths: Task frame {FRAME_TORSO = 0, FRAME_WORLD = 1, FRAME_ROBOT = 2}.
        :param AL::ALValue paths: Vector of 6D position arrays (x,y,z,wx,wy,wz) in meters and radians
        :param AL::ALValue axisMasks: Vector of Axis Masks. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both
        :param AL::ALValue relativeTimes: Vector of times in seconds corresponding to the path points
        """
        return self.proxy.transformInterpolations(effectorNames, taskSpaceForAllPaths, paths, axisMasks, relativeTimes)

    def updateTrackerTarget(self, pTargetPositionWy, pTargetPositionWz, pTimeSinceDetectionMs, pUseOfWholeBody):
        """Update the target to follow by the head of NAO. DEPRECATED Function. Please use ALTracker::lookAt.

        :param float pTargetPositionWy: The target position wy in FRAME_ROBOT
        :param float pTargetPositionWz: The target position wz in  FRAME_ROBOT
        :param int pTimeSinceDetectionMs: The time in Ms since the target was detected
        :param bool pUseOfWholeBody: If true, the target is follow in cartesian space by the Head with whole Body constraints.
        """
        return self.proxy.updateTrackerTarget(pTargetPositionWy, pTargetPositionWz, pTimeSinceDetectionMs, pUseOfWholeBody)

    def version(self):
        """Returns the version of the module.

        :returns str: A string containing the version of the module.
        """
        return self.proxy.version()

    def wait(self, id, timeoutPeriod):
        """Wait for the end of a long running method that was called using 'post'

        :param int id: The ID of the method that was returned when calling the method using 'post'
        :param int timeoutPeriod: The timeout period in ms. To wait indefinately, use a timeoutPeriod of zero.
        :returns bool: True if the timeout period terminated. False if the method returned.
        """
        return self.proxy.wait(id, timeoutPeriod)

    def waitUntilMoveIsFinished(self):
        """Waits until the move process is finished: This method can be used to block your script/code execution until the move task is totally finished.
        """
        return self.proxy.waitUntilMoveIsFinished()

    def waitUntilWalkIsFinished(self):
        """DEPRECATED. Use waitUntilMoveIsFinished function instead.
        """
        return self.proxy.waitUntilWalkIsFinished()

    def wakeUp(self):
        """The robot will wake up: set Motor ON and go to initial position if needed
        """
        return self.proxy.wakeUp()

    def walkInit(self):
        """DEPRECATED. Use moveInit function instead.
        """
        return self.proxy.walkInit()

    def walkIsActive(self):
        """DEPRECATED. Use moveIsActive function instead.

        :returns bool: 
        """
        return self.proxy.walkIsActive()

    def walkTo(self, x, y, theta):
        """DEPRECATED. Use moveTo() function instead.

        :param float x: Distance along the X axis in meters.
        :param float y: Distance along the Y axis in meters.
        :param float theta: Rotation around the Z axis in radians [-3.1415 to 3.1415].
        """
        return self.proxy.walkTo(x, y, theta)

    def walkTo(self, x, y, theta, feetGaitConfig):
        """DEPRECATED. Use moveTo() function instead.

        :param float x: Distance along the X axis in meters.
        :param float y: Distance along the Y axis in meters.
        :param float theta: Rotation around the Z axis in radians [-3.1415 to 3.1415].
        :param AL::ALValue feetGaitConfig: An ALValue with the custom gait configuration for both feet.
        """
        return self.proxy.walkTo(x, y, theta, feetGaitConfig)

    def walkTo(self, controlPoint):
        """DEPRECATED. Use moveTo() function instead.

        :param AL::ALValue controlPoint: An ALValue with all the control point in NAO SPACE[[x1,y1,theta1], ..., [xN,yN,thetaN]
        """
        return self.proxy.walkTo(controlPoint)

    def walkTo(self, controlPoint, feetGaitConfig):
        """DEPRECATED. Use moveTo() function instead.

        :param AL::ALValue controlPoint: An ALValue with all the control point in NAO SPACE[[x1,y1,theta1], ..., [xN,yN,thetaN]
        :param AL::ALValue feetGaitConfig: An ALValue with the custom gait configuration for both feet
        """
        return self.proxy.walkTo(controlPoint, feetGaitConfig)

    def wbEnable(self, isEnabled):
        """UserFriendly Whole Body API: enable Whole Body Balancer. It's a Generalized Inverse Kinematics which deals with cartesian control, balance, redundancy and task priority. The main goal is to generate and stabilized consistent motions without precomputed trajectories and adapt nao's behaviour to the situation. The generalized inverse kinematic problem takes in account equality constraints (keep foot fix), inequality constraints (joint limits, balance, ...) and quadratic minimization (cartesian / articular desired trajectories). We solve each step a quadratic programming on the robot.

        :param bool isEnabled: Active / Disactive Whole Body Balancer.
        """
        return self.proxy.wbEnable(isEnabled)

    def wbEnableBalanceConstraint(self, isEnable, supportLeg):
        """UserFriendly Whole Body API: enable to keep balance in support polygon.

        :param bool isEnable: Enable Nao to keep balance.
        :param str supportLeg: Name of the support leg: "Legs", "LLeg", "RLeg".
        """
        return self.proxy.wbEnableBalanceConstraint(isEnable, supportLeg)

    def wbEnableEffectorControl(self, effectorName, isEnabled):
        """UserFriendly Whole Body API: enable whole body cartesian control of an effector.

        :param str effectorName: Name of the effector : "Head", "LArm" or "RArm". Nao goes to posture init. He manages his balance and keep foot fix. "Head" is controlled in rotation. "LArm" and "RArm" are controlled in position.
        :param bool isEnabled: Active / Disactive Effector Control.
        """
        return self.proxy.wbEnableEffectorControl(effectorName, isEnabled)

    def wbEnableEffectorOptimization(self, effectorName, isActive):
        """Advanced Whole Body API: enable to control an effector as an optimization.

        :param str effectorName: Name of the effector : "All", "Arms", "Legs", "Head", "LArm", "RArm", "LLeg", "RLeg", "Torso", "Com".
        :param bool isActive: if true, the effector control is taken in acount in the optimization criteria.
        """
        return self.proxy.wbEnableEffectorOptimization(effectorName, isActive)

    def wbFootState(self, stateName, supportLeg):
        """UserFriendly Whole Body API: set the foot state: fixed foot, constrained in a plane or free.

        :param str stateName: Name of the foot state. "Fixed" set the foot fixed. "Plane" constrained the Foot in the plane. "Free" set the foot free.
        :param str supportLeg: Name of the foot. "LLeg", "RLeg" or "Legs".
        """
        return self.proxy.wbFootState(stateName, supportLeg)

    def wbGoToBalance(self, supportLeg, duration):
        """Advanced Whole Body API: "Com" go to a desired support polygon. This is a blocking call.

        :param str supportLeg: Name of the support leg: "Legs", "LLeg", "RLeg".
        :param float duration: Time in seconds. Must be upper 0.5 s.
        """
        return self.proxy.wbGoToBalance(supportLeg, duration)

    def wbSetEffectorControl(self, effectorName, targetCoordinate):
        """UserFriendly Whole Body API: set new target for controlled effector. This is a non-blocking call.

        :param str effectorName: Name of the effector : "Head", "LArm" or "RArm". Nao goes to posture init. He manages his balance and keep foot fix. "Head" is controlled in rotation. "LArm" and "RArm" are controlled in position.
        :param AL::ALValue targetCoordinate: "Head" is controlled in rotation (WX, WY, WZ). "LArm" and "RArm" are controlled in position (X, Y, Z). TargetCoordinate must be absolute and expressed in FRAME_ROBOT. If the desired position/orientation is unfeasible, target is resize to the nearest feasible motion.
        """
        return self.proxy.wbSetEffectorControl(effectorName, targetCoordinate)
